# 요구사항
- 기능 목록
    - 회원 기능
        - 회원 등록
        - 회원 조회
    - 상품 기능
        - 상품 등록
        - 상품 수정
        - 상품 조회
    - 주문 기능 
        - 상품 주문
        - 주문 내역 조회
        - 주문 취소
    - 기타 요구사항
        - 상품은 재고 관리가 필요하다.
        - 상품의 종류는 도서, 음반, 영화가 있다. 상품을 카테고리로 구분할 수 있다.
        - 상품 주문시 배송 정보를 입력할 수 있다.

# 도메인 모델과 테이블 설계
1. 회원 1 : N 주문
2. 주문 1 : 1 배송
3. 주문 1 : 다 주문상품 다 : 1 상품
4. 상품 다 : 다 카테고리
5. 상품 (앨범, 책, 영화)

## 엔티티 클래스 개발
- Getter의 경우는 모두 열어두는 것이 편리하다.
- Setter는 열어둘경우 변경에 대해 유지보수가 힘들기 때문에 setter를 사용하지 않고, 메서드를 별도로 제공하는게 좋다.
- 실무에서는 @ManyToMany 쓰지말자 중간테이블 관리가 힘들다 (값을 추가할 수 없다.)
- @Embedded -> 값타입은 생성자를 사용하고 수정자를 쓰지말자( 변경이 불가능해야 한다. )
    - 기본 생성자를 사용해야한다 (jpa 스팩) -> 기본 생성자의 접근 권한을 protected로 해주는 게 좋다.
- jpa가 만들어준 sql ddl을 그대로 사용하지말고 수정해서 사용하자

## 엔티티 설계 주의점
1. 엔티티에는 Setter를 사용하지 말자.
    - 변경 포인트가 많아 유지보수가 어렵다
2. 모든 연관관계는 지연로딩을 설정한다.
    - 즉시로딩(EAGER)은 예측이 어렵고, 어떤 sql이 실행될지 추적하기 어렵다. 특히 jpql을 사용할떄 N+1의 문제가 생긴다.
    - 실무에서 모든 연관관계는 (LAZY)로 설정해야 한다.
    - 함꼐 조회할때는 fetch join 또는 엔티티 그래프 기능을 사용한다.
    - @XToOne은 기본이 EAGER이기 때문에 필히 변경해줘야 한다.
3. 컬렉션 필드는 필드 정의때 초기화해주자
    - `null`에서 안전하다
    - 하이버네이트가 컬렉션을 내장 컬렉션으로 감싸서 변경하기 때문에 내부 메커니즘에 문제가 생긴다
    - 컬렉션을 대체 하지마라
4. 테이블, 컬럼명 생선 기본 전략
    - spring boot
        - camel case를 언더스코어로 바꿈
        - .을 _로
        - SpringPhysicalNamingStrategy
5. cascade
    - type.all -> 생명주기를 같이한다.
    - 참조하는게 다른 곳에서 쓰지 않을때 써야함.

## test에서 spring data source를 적어주지 않는다면 테스트를 돌릴 때 기본적으로 memory mode로 올려준다.


## 변경 감지와 병합 -> 실무에서 항상 변경 감지를 사용하자.
- 기본적으로 jpa는 영속성 컨텍스트에서 관리하는 것들의 변경을 dirty checking을 통해 커밋 시점에 업데이트 쿼리를 날려준다.
- 병합 merge -> itemId를 통해 찾고 파라미터의 값을 모두 바꿔치기함
    - merge()
    - 파라미터로 넘어온 준영속 엔티티의 식별자의 값으로 1차 캐시에 엔티티 조회
    - 없을 때 디비에서 조회 (mergeMember)
    - memrgeMember에 member엔테티 값을 모두 채워 넣는다
    - mergeMember를 반환한다.
- 변경 감지는 원하는 속성만 선택할 수 있다.
- merge는 변경하는 값을 모두 업데이트 친다. -> null값도 변경된다. -> 데이터베이스에 null값이 박힌다.
- 컨트롤러에서 엔티티를 만들지 말자
- 컨트롤러에서 서비스로 파라미터 or dto를 통해 정보를 날리고 서비스에서 엔티티를 검색 한 뒤 변경 감지를 통해 수정하자.
- 실무에서 왠만하면 세터쓰지말자^^





# 2. Jpa  +  API
- 쿼리방식 선택 권장 순서
    1. 엔티티를 DTO로 변환하는 방법 선택
    2. 필요하면 페치조인선택
    3. DTO로 직접 조회하는 방법을 사용한다.
    4. jpa 네이티브 sql이나 스프링 jdbc template을 사용한다.


## fetch join 한계 돌파 + 페이징
- 일대다 조회시 디비에서 다의 기준으로 row를 반환한다.
- 그래서 fetch join에 distinct를 통해 jpa가 줄여준다.
- 그렇지만 페이징 처리를 하려면 결국 memory로 올려서 작업을 해야한다 (out of memory 등의 큰 문제가 발생한다)
- 한계 돌파
- 페이징 + 컬렉션 엔티티 함께 조회 방법
    1. 먼저 ToOne(OneToOne ManyToOne)은 fetch join으로 가져온다
    2. 컬렉션은 지연 로딩으로 조회한다.
    3. `hibernate.default_batch_fetch_size` `@BatchSize`
        - hibernate -> global설정
        - batchsize 개별 최적화
    4. 장점
        - 쿼리 호출 수가 1+N -> 1+1로 최적화가 된다.
        - 컬렉션 페치조인은 페이징 불가하지만 위의 방법은 가능
        - db데이터 전송량이 감소한다.
    5. 왠만하면 default_batch_size 로 정리해버린다.
        - 적당한 사이즈는 100~1000개 정도로 정한다.
        - sql in 절은 데이터베이스에 따라 파라미터 제한이 있다.
        - 1000개로 하면 데이터베이스에 순간적으로 부하가 증가함
        - 1000으로 설정하는 것이 가장 좋지만, 순간 부하를 견딜 수 있는 정도로 결정하면 된다.
        - 애매하면 100~500 정도 두고 쓰자~
- 여기까지하면 거의 성능 최적화 끝남

### API 개발 정리
- 엔티티 조회
    - 엔티티를 절대 api에서 반환하지말자
    - 엔티티 조회 후 DTO로 변환하자
    - 페치 조인으로 쿼리 수 최적화
    - 컬렉션 페이징과 한계 돌파
        - 컬렉션 페치 조인시 페이징이 불가능
        - To One 관계는 페치 조인 가능
        - 컬렉션은 페치 조인 대신에 hibernate.default_batch_fetch_size, @BatchSize로 최적화한다.
- DTO 직접 조회
    - 일대 다 관계인 컬렉션은 In 절을 활용해서 메모리에서 미리 조회
    - join 결과를 그대로 조회 후 어플리케이션에서 재조립

- 권장 순서
1. 엔티티 조회 방식으로 우선 접근
    - 페치조인으로 쿼리 수 최적화
    - 컬렉션 최적화
    - 페이징 관련 최적화
2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식으로 사용
3. DTO 조회 방식으로 해결이 안되면 NativeSql or 스프링 JdbcTemplate으로 해결
4. 엔티티 조회 방식은 페치 조인이나 batch size만 변경해서 성능 최적화를 시도할 수 있다. 하지만 dto는 코드 수정이 너무 많아진다.

## Osiv 성능 최적화
- Open Session In View : 하이버네이트
- Open EntityManager In View : JPA
- `spring.jpa.open-in-view` : true -> default
- jpa가 데이터커넥션을 데이터베이스 트랜잭션을 시작할 때 가져온다. -> osiv가 켜져있으면 api 가 반환댈때까지 데이터베이스커넥션을 가지고 있는다.
- 그렇기 때문에 컨트롤러에서도 지연로딩이 사용 된다( 결국 영속성 컨텍스트가 살아 있다)
- 데이터베이스 커넥션을 오래 가지고 있기 때문에 실시간 트래픽이 중요한 서비스에서는 커넥션이 모자랄 수 있다.
- osiv를 끄고 사용하면 트랜잭션이 종료할때 영속성 컨텍스트 닫고 데이터베이스 커넥션도 반환한다.
    - 지연로딩을 트랜잭션 안에서 모든걸 처리해야한다.
    - 끈 상태로 외부에서 지연로딩을 사용하면 LazyInitializationException 이 발생한다.
    - 트랜잭션에서 로딩하거나 페치조인을 사용한다.
- 실무에서 끈 상태로 관리하는 방법
    - command와 query를 분리한다.
    - 복잡한 화면을 출력하기 위한 쿼리를 화면에 맞추어 성능을 최적화 하는 것이 중요하다.
    - ex)
        - OrderService : 핵심 비즈니스 로직
        - OrderQueryService : 화면이나 API에 맞춘 서비스
    - 고객 서비스의 실시간 api는 osiv를 끄고 admin처럼 커넥션을 많이 사용하지 않는 곳에서는 osiv를 켠다.